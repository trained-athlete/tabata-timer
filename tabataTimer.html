
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tabata Timer</title>
  <style>
    :root {
      --bg: #0f172a;        /* slate-900 */
      --panel: #111827;     /* gray-900 */
      --text: #e5e7eb;      /* gray-200 */
      --muted: #9ca3af;     /* gray-400 */
      --accent: #22c55e;    /* green-500 */
      --accent2: #ef4444;   /* red-500 */
      --accent3: #3b82f6;   /* blue-500 */
      --accent4: #f59e0b;   /* amber-500 */
      --border: #1f2937;    /* gray-800 */
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(135deg, #0f172a 0%, #111827 100%);
      color: var(--text);
      min-height: 100vh; display: grid; place-items: center; padding: 24px;
    }
    .app {
      width: 100%; max-width: 900px; background: rgba(17,24,39,0.8);
      border: 1px solid var(--border); border-radius: 16px; backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    header {
      padding: 18px 22px; border-bottom: 1px solid var(--border);
      display: flex; align-items: center; justify-content: space-between;
    }
    header h1 { margin: 0; font-size: 20px; letter-spacing: 0.4px; }
    .mode-badge {
      font-size: 12px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px;
      color: var(--muted);
    }
    .grid {
      display: grid; grid-template-columns: 1.1fr 0.9fr; gap: 0; 
    }
    @media (max-width: 860px) {
      .grid { grid-template-columns: 1fr; }
    }
    .panel {
      padding: 20px; border-right: 1px solid var(--border);
    }
    .panel:last-child { border-right: none; }
    .section-title {
      font-size: 14px; text-transform: uppercase; color: var(--muted); letter-spacing: 1px;
      margin: 8px 0 12px;
    }
    .timer-face {
      display: grid; grid-template-columns: 1fr; grid-template-rows: auto auto auto; gap: 12px;
      align-items: center; text-align: center; padding: 12px;
    }
    .phase {
      font-size: 14px; letter-spacing: 2px; text-transform: uppercase;
      padding: 8px 12px; border-radius: 8px; display: inline-block;
      border: 1px solid var(--border);
    }
    .phase.work { color: #10b981; border-color: #064e3b; background: rgba(16,185,129,0.08); }
    .phase.rest { color: #f97316; border-color: #7c2d12; background: rgba(249,115,22,0.08); }
    .phase.prepare { color: #3b82f6; border-color: #1e3a8a; background: rgba(59,130,246,0.08); }
    .phase.done { color: #eab308; border-color: #78350f; background: rgba(234,179,8,0.08); }
    .time {
      font-size: clamp(40px, 8vw, 88px); font-weight: 700; letter-spacing: 2px;
    }
    .subline {
      color: var(--muted); font-size: 14px;
    }
    .progress {
      height: 12px; background: #0b1220; border: 1px solid var(--border); border-radius: 999px; overflow: hidden;
    }
    .progress > div {
      height: 100%; width: 0%; transition: width 0.25s ease; background: linear-gradient(90deg, var(--accent), #3b82f6);
    }
    .session-progress > div {
      background: linear-gradient(90deg, var(--accent4), var(--accent3));
    }
    .controls {
      display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 14px;
    }
    .btn {
      padding: 12px 14px; border-radius: 10px; border: 1px solid var(--border); background: #0b1220; color: var(--text);
      cursor: pointer; font-weight: 600; transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select: none;
    }
    .btn:hover { transform: translateY(-1px); background: #0d1526; }
    .btn.primary { background: #0a1a2f; border-color: #1f2937; }
    .btn.green { background: #052e26; border-color: #064e3b; color: #10b981; }
    .btn.orange { background: #2b1d07; border-color: #7c2d12; color: #f59e0b; }
    .btn.red { background: #2b0d0d; border-color: #7f1d1d; color: #ef4444; }
    .btn.blue { background: #0b1d36; border-color: #1e3a8a; color: #3b82f6; }
    .settings {
      display: grid; grid-template-columns: repeat(2, 1fr); gap: 14px;
    }
    .field {
      display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 10px; align-items: center; padding: 10px; border: 1px solid var(--border); border-radius: 12px;
      background: #0b1220;
    }
    .field label { font-size: 13px; color: var(--muted); }
    .field input {
      width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: #091020; color: var(--text);
      font-size: 14px; text-align: center;
    }
    .field small { color: var(--muted); display: block; margin-top: 4px; }
    .toggles {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 12px;
    }
    .toggle {
      display: flex; align-items: center; gap: 10px; padding: 10px; border: 1px solid var(--border); border-radius: 12px; background: #0b1220;
    }
    .toggle input { transform: scale(1.3); }
    .stats {
      margin-top: 10px; border-top: 1px solid var(--border); padding-top: 12px; font-size: 14px; color: var(--muted);
    }
    footer {
      border-top: 1px solid var(--border); padding: 14px 20px; font-size: 12px; color: var(--muted); display: flex; justify-content: space-between; align-items: center;
    }
    .kbd {
      border: 1px solid var(--border); background: #0b1220; padding: 3px 6px; border-radius: 6px; font-size: 11px; color: var(--text);
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Tabata Timer">
    <header>
      <h1>Tabata Timer</h1>
      <div class="mode-badge">Dark Mode ‚Ä¢ Offline</div>
    </header>

    <div class="grid">
      <!-- Left: Timer -->
      <section class="panel" aria-labelledby="timer-section">
        <div class="section-title" id="timer-section">Timer</div>
        <div class="timer-face">
          <div id="phaseBadge" class="phase prepare">Prepare</div>
          <div id="clock" class="time" aria-live="polite">00:10</div>
          <div class="subline" id="subline">Round 1 / 8 ‚Ä¢ Cycle 1 / 1</div>

          <div class="progress" aria-label="Interval progress"><div id="intervalProgress"></div></div>
          <div class="progress session-progress" aria-label="Session progress"><div id="sessionProgress"></div></div>

          <div class="controls">
            <button class="btn green" id="btnStart" aria-label="Start (Space)">‚ñ∂ Start</button>
            <button class="btn orange" id="btnPause" aria-label="Pause (Space)">‚è∏ Pause</button>
            <button class="btn red" id="btnReset" aria-label="Reset (R)">‚ü≤ Reset</button>
            <button class="btn blue" id="btnSkip" aria-label="Skip interval (N)">‚è≠ Skip</button>
            <button class="btn" id="btnMute" aria-label="Mute sounds">üîà Sound: On</button>
          </div>
        </div>
      </section>

      <!-- Right: Settings -->
      <section class="panel" aria-labelledby="settings-section">
        <div class="section-title" id="settings-section">Settings</div>

        <div class="settings">
          <div class="field">
            <div>
              <label for="prep">Prepare (sec)</label>
              <small>Countdown before the first work interval</small>
            </div>
            <input id="prep" type="number" min="0" value="10" />
          </div>

          <div class="field">
            <div>
              <label for="work">Work (sec)</label>
              <small>High-intensity interval</small>
            </div>
            <input id="work" type="number" min="1" value="20" />
          </div>

          <div class="field">
            <div>
              <label for="rest">Rest (sec)</label>
              <small>Recovery interval</small>
            </div>
            <input id="rest" type="number" min="0" value="10" />
          </div>

          <div class="field">
            <div>
              <label for="rounds">Rounds per cycle</label>
              <small>Work+Rest repetitions</small>
            </div>
            <input id="rounds" type="number" min="1" value="8" />
          </div>

          <div class="field">
            <div>
              <label for="cycles">Cycles</label>
              <small>Sets of rounds</small>
            </div>
            <input id="cycles" type="number" min="1" value="1" />
          </div>

          <div class="field">
            <div>
              <label for="longrest">Long Rest (sec)</label>
              <small>Between cycles</small>
            </div>
            <input id="longrest" type="number" min="0" value="60" />
          </div>
        </div>

        <div class="toggles">
          <label class="toggle"><input id="autoNext" type="checkbox" checked /> Auto next interval</label>
          <label class="toggle"><input id="sessionBeep" type="checkbox" checked /> Beeps at phase changes</label>
        </div>

        <div class="stats" id="stats">Total session time: ‚Äì</div>
      </section>
    </div>

    <footer>
      <div>Shortcuts: <span class="kbd">Space</span> Start/Pause ‚Ä¢ <span class="kbd">R</span> Reset ‚Ä¢ <span class="kbd">N</span> Skip</div>
      <div id="summary"></div>
    </footer>
  </div>

  <script>
    // ===== Utility: format seconds (mm:ss) =====
    function fmt(t) {
      const m = Math.floor(t / 60), s = Math.floor(t % 60);
      return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
    }

    // ===== Simple Web Audio beeps =====
    const audioCtx = (typeof AudioContext !== 'undefined') ? new AudioContext() : null;
    const SOUND = {
      enabled: true,
      beep(freq = 880, dur = 0.18, type = 'sine', vol = 0.08) {
        if (!audioCtx || !SOUND.enabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.value = freq;
        gain.gain.value = vol;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
      },
      tripleCountdown() { // 3‚Äì2‚Äì1 beeps
        [660, 660, 990].forEach((f, i) => setTimeout(() => SOUND.beep(f, 0.12), i * 200));
      },
      bell() { SOUND.beep(440, 0.25, 'triangle', 0.12); SOUND.beep(880, 0.25, 'sine', 0.08); }
    };

    // ===== Elements =====
    const els = {
      clock: document.getElementById('clock'),
      phase: document.getElementById('phaseBadge'),
      subline: document.getElementById('subline'),
      intervalBar: document.getElementById('intervalProgress'),
      sessionBar: document.getElementById('sessionProgress'),
      stats: document.getElementById('stats'),
      summary: document.getElementById('summary'),
      start: document.getElementById('btnStart'),
      pause: document.getElementById('btnPause'),
      reset: document.getElementById('btnReset'),
      skip: document.getElementById('btnSkip'),
      mute: document.getElementById('btnMute'),
      inputs: {
        prep: document.getElementById('prep'),
        work: document.getElementById('work'),
        rest: document.getElementById('rest'),
        rounds: document.getElementById('rounds'),
        cycles: document.getElementById('cycles'),
        longrest: document.getElementById('longrest'),
        autoNext: document.getElementById('autoNext'),
        sessionBeep: document.getElementById('sessionBeep'),
      }
    };

    // ===== State =====
    const STATE = {
      phase: 'prepare', // prepare | work | rest | longrest | done
      remaining: 10,
      totals: {
        prep: 10, work: 20, rest: 10,
        rounds: 8, cycles: 1, longrest: 60
      },
      iRound: 1, iCycle: 1,
      timerId: null, running: false,
      sessionTotalSec: 0, sessionElapsedSec: 0
    };

    // ===== Persistence =====
    const LS_KEY = 'tabata.settings.v1';
    function loadSettings() {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      try {
        const s = JSON.parse(raw);
        for (const k of ['prep','work','rest','rounds','cycles','longrest']) {
          if (typeof s[k] === 'number') els.inputs[k].value = s[k];
        }
        els.inputs.autoNext.checked = !!s.autoNext;
        els.inputs.sessionBeep.checked = !!s.sessionBeep;
        SOUND.enabled = s.soundEnabled !== false;
        els.mute.textContent = SOUND.enabled ? 'üîà Sound: On' : 'üîá Sound: Off';
      } catch {}
    }
    function saveSettings() {
      const s = currentTotals();
      s.autoNext = els.inputs.autoNext.checked;
      s.sessionBeep = els.inputs.sessionBeep.checked;
      s.soundEnabled = SOUND.enabled;
      localStorage.setItem(LS_KEY, JSON.stringify(s));
    }

    // ===== Helpers =====
    function currentTotals() {
      return {
        prep: +els.inputs.prep.value || 0,
        work: +els.inputs.work.value || 1,
        rest: +els.inputs.rest.value || 0,
        rounds: Math.max(1, +els.inputs.rounds.value || 1),
        cycles: Math.max(1, +els.inputs.cycles.value || 1),
        longrest: +els.inputs.longrest.value || 0
      };
    }

    function computeSessionTotal(t) {
      const oneRound = t.work + t.rest;
      const perCycle = t.prep + (oneRound * t.rounds);
      const betweenCycles = (t.cycles > 1) ? (t.longrest * (t.cycles - 1)) : 0;
      return (perCycle * t.cycles) + betweenCycles;
    }

    function updateStats() {
      const t = currentTotals();
      const total = computeSessionTotal(t);
      els.stats.textContent =
        `Total session time: ${fmt(total)} ‚Ä¢ Work: ${t.work}s ‚Ä¢ Rest: ${t.rest}s ‚Ä¢ Rounds: ${t.rounds} ‚Ä¢ Cycles: ${t.cycles}`;
    }

    function setPhase(name) {
      STATE.phase = name;
      els.phase.className = 'phase ' + (name === 'done' ? 'done' : name);
      const labels = { prepare: 'Prepare', work: 'Work', rest: 'Rest', longrest: 'Long Rest', done: 'Done' };
      els.phase.textContent = labels[name] || name;
    }

    function updateSubline() {
      els.subline.textContent = (STATE.phase === 'longrest' || STATE.phase === 'done')
        ? `Cycle ${STATE.iCycle} / ${STATE.totals.cycles}`
        : `Round ${STATE.iRound} / ${STATE.totals.rounds} ‚Ä¢ Cycle ${STATE.iCycle} / ${STATE.totals.cycles}`;
    }

    function updateBars() {
      const totalInterval =
        STATE.phase === 'prepare' ? STATE.totals.prep :
        STATE.phase === 'work' ? STATE.totals.work :
        STATE.phase === 'rest' ? STATE.totals.rest :
        STATE.phase === 'longrest' ? STATE.totals.longrest : 1;
      const intervalPct = totalInterval ? (1 - STATE.remaining / totalInterval) * 100 : 100;
      els.intervalBar.style.width = `${Math.min(100, Math.max(0, intervalPct))}%`;

      const pct = STATE.sessionTotalSec ? (STATE.sessionElapsedSec / STATE.sessionTotalSec) * 100 : 0;
      els.sessionBar.style.width = `${Math.min(100, Math.max(0, pct))}%`;
    }

    function renderClock() { els.clock.textContent = fmt(STATE.remaining); updateBars(); updateSubline(); }

    function nextPhase() {
      const t = STATE.totals;
      if (STATE.phase === 'prepare') {
        STATE.phase = 'work'; STATE.remaining = t.work;
      } else if (STATE.phase === 'work') {
        // After work, either rest or move to next round/cycle
        if (STATE.iRound < t.rounds && t.rest > 0) {
          STATE.phase = 'rest'; STATE.remaining = t.rest;
        } else {
          // Round completed
          if (STATE.iRound < t.rounds) {
            STATE.iRound++;
            STATE.phase = 'work'; STATE.remaining = t.work;
          } else {
            // Cycle end
            if (STATE.iCycle < t.cycles) {
              STATE.iCycle++;
              if (t.longrest > 0) { STATE.phase = 'longrest'; STATE.remaining = t.longrest; }
              else { STATE.phase = 'work'; STATE.remaining = t.work; STATE.iRound = 1; }
            } else {
              STATE.phase = 'done'; STATE.remaining = 0; stopTimer();
            }
          }
        }
      } else if (STATE.phase === 'rest') {
        // After rest, proceed to next round
        if (STATE.iRound < t.rounds) {
          STATE.iRound++;
          STATE.phase = 'work'; STATE.remaining = t.work;
        } else {
          // End of cycle
          if (STATE.iCycle < t.cycles) {
            STATE.iCycle++;
            if (t.longrest > 0) { STATE.phase = 'longrest'; STATE.remaining = t.longrest; }
            else { STATE.phase = 'work'; STATE.remaining = t.work; STATE.iRound = 1; }
          } else {
            STATE.phase = 'done'; STATE.remaining = 0; stopTimer();
          }
        }
      } else if (STATE.phase === 'longrest') {
        // After long rest, new cycle starts
        STATE.iRound = 1;
        STATE.phase = 'work'; STATE.remaining = t.work;
      }

      if (els.inputs.sessionBeep.checked) {
        if (STATE.phase === 'work') SOUND.bell();
        else if (STATE.phase === 'rest') SOUND.tripleCountdown();
        else if (STATE.phase === 'longrest') SOUND.beep(520, 0.18);
        else if (STATE.phase === 'done') SOUND.bell();
      }
      setPhase(STATE.phase);
      renderClock();
    }

    function tick() {
      if (!STATE.running) return;
      STATE.remaining = Math.max(0, STATE.remaining - 1);
      STATE.sessionElapsedSec = Math.min(STATE.sessionTotalSec, STATE.sessionElapsedSec + 1);
      renderClock();
      if (STATE.remaining <= 0) {
        if (STATE.phase !== 'done' && els.inputs.autoNext.checked) nextPhase();
      }
    }

    function startTimer() {
      if (STATE.running) return;
      // resume audio context (required by some browsers)
      if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume(); }
      STATE.running = true;
      els.start.textContent = '‚ñ∂ Start';
      if (!STATE.timerId) STATE.timerId = setInterval(tick, 1000);
    }

    function pauseTimer() {
      STATE.running = false;
      els.start.textContent = '‚ñ∂ Start';
    }

    function stopTimer() {
      STATE.running = false;
      if (STATE.timerId) { clearInterval(STATE.timerId); STATE.timerId = null; }
    }

    function resetSession() {
      stopTimer();
      STATE.totals = currentTotals();
      STATE.iRound = 1; STATE.iCycle = 1;
      STATE.phase = 'prepare';
      STATE.remaining = STATE.totals.prep;
      STATE.sessionTotalSec = computeSessionTotal(STATE.totals);
      STATE.sessionElapsedSec = 0;
      setPhase('prepare');
      renderClock();
      updateStats();
      els.summary.textContent = '';
    }

    function skipInterval() {
      if (STATE.phase === 'done') return;
      nextPhase();
    }

    // ===== Event bindings =====
    els.start.addEventListener('click', startTimer);
    els.pause.addEventListener('click', pauseTimer);
    els.reset.addEventListener('click', () => { resetSession(); saveSettings(); });
    els.skip.addEventListener('click', skipInterval);
    els.mute.addEventListener('click', () => {
      SOUND.enabled = !SOUND.enabled;
      els.mute.textContent = SOUND.enabled ? 'üîà Sound: On' : 'üîá Sound: Off';
      saveSettings();
    });

    // Inputs change
    Object.values(els.inputs).forEach(inp => {
      inp.addEventListener && inp.addEventListener('change', () => {
        saveSettings();
        resetSession();
      });
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); STATE.running ? pauseTimer() : startTimer(); }
      else if (e.key.toLowerCase() === 'r') { e.preventDefault(); resetSession(); saveSettings(); }
      else if (e.key.toLowerCase() === 'n') { e.preventDefault(); skipInterval(); }
    });

    // Init
    loadSettings();
    resetSession();
  </script>
</body>
</html>
``
